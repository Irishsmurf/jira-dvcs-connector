package com.atlassian.jira.plugins.dvcs.spi.bitbucket.activity;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.atlassian.jira.plugins.dvcs.activity.RepositoryActivityCommitMapping;
import com.atlassian.jira.plugins.dvcs.activity.RepositoryActivityDao;
import com.atlassian.jira.plugins.dvcs.activity.RepositoryActivityPullRequestCommentMapping;
import com.atlassian.jira.plugins.dvcs.activity.RepositoryActivityPullRequestMapping;
import com.atlassian.jira.plugins.dvcs.activity.RepositoryActivityPullRequestUpdateMapping;
import com.atlassian.jira.plugins.dvcs.activity.RepositoryActivitySynchronizer;
import com.atlassian.jira.plugins.dvcs.activity.RepositoryPullRequestMapping;
import com.atlassian.jira.plugins.dvcs.dao.RepositoryDao;
import com.atlassian.jira.plugins.dvcs.model.Repository;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.BitbucketClientRemoteFactory;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.activeobjects.BitbucketPullRequestCommitMapping;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.client.BitbucketRemoteClient;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.client.ClientUtils;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.model.BitbucketPullRequest;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.model.BitbucketPullRequestActivityInfo;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.model.BitbucketPullRequestApprovalActivity;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.model.BitbucketPullRequestBaseActivity;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.model.BitbucketPullRequestCommentActivity;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.model.BitbucketPullRequestCommit;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.model.BitbucketPullRequestUpdateActivity;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.model.HasMessages;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.clientlibrary.restpoints.PullRequestRemoteRestpoint;
import com.atlassian.jira.plugins.dvcs.spi.bitbucket.dao.BitbucketPullRequestDao;
import com.atlassian.jira.plugins.dvcs.util.IssueKeyExtractor;

// TODO failure recovery + rename to stateful if will be stateful
public class BitbucketRepositoryActivitySynchronizer implements RepositoryActivitySynchronizer
{

    private final BitbucketClientRemoteFactory clientFactory;
    private final RepositoryActivityDao dao;
    private final RepositoryDao repositoryDao;
    private final BitbucketPullRequestDao pullRequestDao;
    
    public BitbucketRepositoryActivitySynchronizer(BitbucketClientRemoteFactory clientFactory, RepositoryActivityDao dao,
            RepositoryDao repositoryDao, BitbucketPullRequestDao pullRequestDao)
    {
        super();
        this.clientFactory = clientFactory;
        this.dao = dao;
        this.repositoryDao = repositoryDao;
        this.pullRequestDao = pullRequestDao;
    }

    @Override
    public void synchronize(Repository forRepository, boolean softSync)
    {
        if (!softSync)
        {
            dao.removeAll(forRepository);
            forRepository.setActivityLastSync(null);
        }

        BitbucketRemoteClient remoteClient = clientFactory.getForRepository(forRepository, 2);
        PullRequestRemoteRestpoint pullRestpoint = remoteClient.getPullRequestAndCommentsRemoteRestpoint();

        //
        // get activities iterator
        //
        Iterable<BitbucketPullRequestActivityInfo> activities = pullRestpoint.getRepositoryActivity(
                forRepository.getOrgName(), forRepository.getSlug(), forRepository.getActivityLastSync());

        Date lastActivitySyncDate = forRepository.getActivityLastSync();
        
        Date previousActivityDate = null;
        //
        // check whether there's some interesting issue keys in activity
        // and persist it if yes
        //
        try
        {
	        for (BitbucketPullRequestActivityInfo info : activities)
	        {
	            Date activityDate = ClientUtils.extractActivityDate(info.getActivity());
	            if (lastActivitySyncDate == null)
	            {
	                lastActivitySyncDate = activityDate;
	            } else
	            {
	                if (activityDate!=null && activityDate.after(lastActivitySyncDate))
	                {
	                    lastActivitySyncDate = activityDate;
	                }
	            }
	            
	            // filtering duplicated activities in response
	            //TODO implement better checking whether activity is duplicated than comparing dates
	            if (!activityDate.equals(previousActivityDate))
	            {
	            	PullRequestContext pullRequestContext = getPullRequestContext(info.getPullRequest().getId());
	            	
	            	processActivity(info, forRepository, pullRestpoint, pullRequestContext);
	            }
	            previousActivityDate = activityDate;
	        }
	        
	        for ( Long pullRequestRemoteId : context.keySet() )
	        {
	        	PullRequestContext pullRequestContext = context.get(pullRequestRemoteId);
	            // when soft sync, it could happen that we have no update activities and therefore no last update activity and iterator
	            if (pullRequestContext.getLastUpdateActivityId() != null)
	            {	
		        	fillCommits(null, pullRequestContext);
		        	// there are no more commits, this activity must be the first
		        	if (!pullRequestContext.getCommitIterator().iterator().hasNext())
		        	{
		        		dao.updateActivityStatus(pullRequestContext.getLastUpdateActivityId(), RepositoryActivityPullRequestUpdateMapping.Status.OPENED);
		        		
		        	}
	            }

	            dao.updatePullRequestIssueKeys(pullRequestContext.getLocalPullRequestId());
	        }
        } finally
        {
        	context.clear();
        }

        // { finally
        repositoryDao.setLastActivitySyncDate(forRepository.getId(), lastActivitySyncDate);
    }

    // -------------------------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------------------------
    // Helpers ...
    // -------------------------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------------------------

	private void processActivity(BitbucketPullRequestActivityInfo info, Repository forRepository,
            PullRequestRemoteRestpoint pullRestpoint, PullRequestContext pullRequestContext)
    {
        int localPullRequestId = ensurePullRequestPresent(forRepository, pullRestpoint, info, pullRequestContext);
        BitbucketPullRequestBaseActivity activity = info.getActivity();
        
        RepositoryActivityPullRequestMapping mapping = dao.saveActivity(toDaoModel(info.getActivity(), forRepository, localPullRequestId));
        
        if (isUpdateActivity(activity))
        {
            if (pullRequestContext.getFirstCommit() != null)
            {
                pullRequestContext.setLastUpdateActivityId(mapping.getID());
            }
        }
    }

    private boolean isUpdateActivity(BitbucketPullRequestBaseActivity activity)
    {
        return activity instanceof BitbucketPullRequestUpdateActivity && "open".equals(((BitbucketPullRequestUpdateActivity) activity).getStatus());
    }
    
    private PullRequestContext getPullRequestContext(long pullRequestRemoteId)
    {
    	PullRequestContext pullRequestContext = context.get(pullRequestRemoteId);
        
    	if (pullRequestContext == null)
        {
    		pullRequestContext = new PullRequestContext();
            context.put(pullRequestRemoteId, pullRequestContext);
        }
    	
    	return pullRequestContext;
    }
    
    // TODO improve performance here [***] , as this is gonna to call often 
    private int ensurePullRequestPresent(Repository forRepository,
            PullRequestRemoteRestpoint pullRestpoint, BitbucketPullRequestActivityInfo info, PullRequestContext pullRequestContext)
    {
        // go for pull request details [***]
        BitbucketPullRequest remotePullRequest = pullRestpoint.getPullRequestDetail(forRepository.getOrgName(),
                forRepository.getSlug(), info.getPullRequest().getId() + "");

        RepositoryPullRequestMapping localPullRequest = dao.findRequestByRemoteId(forRepository.getId(),
                info.getPullRequest().getId());
        
        loadPullRequestCommits(remotePullRequest, pullRestpoint, localPullRequest);
        
        // don't have this pull request, let's save it
        if (localPullRequest == null)
        {
            localPullRequest = dao.savePullRequest(toDaoModelPullRequest(remotePullRequest, forRepository));

          // already have it, let's find new issue keys
        }
        
        pullRequestContext.setLocalPullRequestId(localPullRequest.getID());
 
        
        // go for commits details [***]
        fillActivityCommits(info, pullRestpoint, pullRequestContext);

        return pullRequestContext.getLocalPullRequestId();
    }

    private void loadPullRequestCommits(BitbucketPullRequest remotePullRequest, PullRequestRemoteRestpoint pullRestpoint, RepositoryPullRequestMapping localPullRequest)
    {
    	Iterable<BitbucketPullRequestCommit> commitsIterator = pullRestpoint.getPullRequestCommits(remotePullRequest.getLinks().getCommitsHref());
    	List<BitbucketPullRequestCommit> prCommits = new ArrayList<BitbucketPullRequestCommit>();
    	int order = 0;
    	for (BitbucketPullRequestCommit commit : commitsIterator)
    	{
    		RepositoryActivityCommitMapping commitMapping = dao.saveCommit(toDaoModelCommit(commit, null));
    		pullRequestDao.saveCommit(commitMapping.getID(), order++, localPullRequest.getID());
    	}
    	
<<<<<<< mine
    	remotePullRequest.setCommitsDetails(prCommits);
=======
        if (!issueKeys.isEmpty())
        {
            // FIXME - was removed - currently it is handled automatically
            // dao.saveIssueKeysMappings(issueKeys, localPullRequestId);
        }
    }
    
    private Set<String> extractIssueKeys(HasMessages messageProvider)
    {
        Set<String> ret = new HashSet<String>();
        Iterable<String> messages = messageProvider.getMessages();

        for (String message : messages)
        {
            Set<String> issueKeysFromMessage = IssueKeyExtractor.extractIssueKeys(message);
            if (!issueKeysFromMessage.isEmpty())
            {
                ret.addAll(issueKeysFromMessage);
            }
        }
        return ret;
>>>>>>> theirs
    }
    
    private Map<String, Object> toDaoModel(BitbucketPullRequestBaseActivity activity, Repository forRepository, Integer pullRequestId)
    {
        Map<String, Object> ret = getAsCommonProperties(activity, forRepository, pullRequestId);

        if (activity instanceof BitbucketPullRequestCommentActivity)
        {
        	BitbucketPullRequestCommentActivity commentActivity = (BitbucketPullRequestCommentActivity) activity;
    		ret.put(RepositoryActivityPullRequestMapping.ENTITY_TYPE, RepositoryActivityPullRequestCommentMapping.class);
    		ret.put(RepositoryActivityPullRequestCommentMapping.REMOTE_ID,  new Long(commentActivity.getId()));
    		if (commentActivity.getParent() != null)
    		{
    			ret.put(RepositoryActivityPullRequestCommentMapping.REMOTE_PARENT_ID, commentActivity.getParent().getId());
    		}
    		if (commentActivity.getContent() != null)
            {
                ret.put(RepositoryActivityPullRequestCommentMapping.MESSAGE, commentActivity.getContent().getRaw());
            }
    		if (commentActivity.getInline() != null)
    		{
    			ret.put(RepositoryActivityPullRequestCommentMapping.FILE, commentActivity.getInline().getPath());
    		}
        } else if (activity instanceof BitbucketPullRequestApprovalActivity)
        {
            ret.put(RepositoryActivityPullRequestMapping.ENTITY_TYPE, RepositoryActivityPullRequestUpdateMapping.class);
            ret.put(RepositoryActivityPullRequestUpdateMapping.STATUS, RepositoryActivityPullRequestUpdateMapping.Status.APPROVED);

        } else if (activity instanceof BitbucketPullRequestUpdateActivity)
        {
            ret.put(RepositoryActivityPullRequestMapping.ENTITY_TYPE, RepositoryActivityPullRequestUpdateMapping.class);
            ret.put(RepositoryActivityPullRequestUpdateMapping.STATUS, transformStatus((BitbucketPullRequestUpdateActivity) activity));
        }
        return ret;
    }

    private RepositoryActivityPullRequestUpdateMapping.Status transformStatus(BitbucketPullRequestUpdateActivity activity)
    {
        String status = activity.getStatus();
        if ("open".equals(status))
        {
        	// we save all updates with status updated, first update will be updated to opened
            return RepositoryActivityPullRequestUpdateMapping.Status.UPDATED;
        }
        if ("update".equals(status))
        {
        	return RepositoryActivityPullRequestUpdateMapping.Status.UPDATED;
        }
        if ("fulfilled".equals(status))
        {
            return RepositoryActivityPullRequestUpdateMapping.Status.MERGED;
        }
        if ("rejected".equals(status))
        {
            return RepositoryActivityPullRequestUpdateMapping.Status.DECLINED;
        }
        
        return null;
    }
    
    private HashMap<String, Object> getAsCommonProperties(BitbucketPullRequestBaseActivity activity, Repository forRepository, Integer pullRequestId)
    {
        HashMap<String, Object> ret = new HashMap<String, Object>();
        ret.put(RepositoryActivityPullRequestMapping.LAST_UPDATED_ON, ClientUtils.extractActivityDate(activity));
        ret.put(RepositoryActivityPullRequestMapping.AUTHOR, activity.getUser().getUsername());
        ret.put(RepositoryActivityPullRequestMapping.RAW_AUTHOR, activity.getUser().getDisplayName());
        ret.put(RepositoryActivityPullRequestMapping.PULL_REQUEST_ID, pullRequestId);
        ret.put(RepositoryActivityPullRequestMapping.REPOSITORY_ID, forRepository.getId());
        return ret;
    }

    private Map<String, Object> toDaoModelPullRequest(BitbucketPullRequest request, Repository repository)
    {
        HashMap<String, Object> ret = new HashMap<String, Object>();
        ret.put(RepositoryPullRequestMapping.REMOTE_ID, request.getId());
        ret.put(RepositoryPullRequestMapping.NAME, request.getTitle());
        ret.put(RepositoryPullRequestMapping.URL, repository.getOrgHostUrl() + request.getLinks().getHtmlHref());
        ret.put(RepositoryPullRequestMapping.TO_REPO_ID, repository.getId());
        // in case that fork has been deleted, the source repository is null 
        if (request.getSource().getRepository() != null)
        {
        	String sourceRepositoryUrl = repository.getOrgHostUrl() + request.getSource().getRepository().getLinks().getHtmlHref();
            ret.put(RepositoryPullRequestMapping.SOURCE_URL, sourceRepositoryUrl);
        }
        
        return ret;
    }

    private Map<String,Object> toDaoModelCommit(BitbucketPullRequestCommit commit, Integer activityId)
    {
        HashMap<String, Object> ret = new HashMap<String, Object>();
        ret.put(RepositoryActivityCommitMapping.ACTIVITY_ID , activityId);
        ret.put(RepositoryActivityCommitMapping.AUTHOR, commit.getAuthor().getUser().getUsername());
        ret.put(RepositoryActivityCommitMapping.RAW_AUTHOR, commit.getAuthor().getRaw());
        ret.put(RepositoryActivityCommitMapping.MESSAGE, commit.getMessage());
        ret.put(RepositoryActivityCommitMapping.NODE, commit.getSha());
        ret.put(RepositoryActivityCommitMapping.DATE, commit.getDate());
        
        return ret;
    }
    
    private Map<Long, PullRequestContext> context = new HashMap<Long, PullRequestContext>();
    
    private void fillActivityCommits(BitbucketPullRequestUpdateActivity activity, PullRequestContext pullRequestContext, RepositoryActivityPullRequestUpdateMapping localActivity)
    {
    	boolean firstCommitFound = false;
        for ( BitbucketPullRequestCommitMapping commit : pullRequestDao.getCommitsForPullRequest(pullRequestContext.getLocalPullRequestId()))
        {
        	RepositoryActivityCommitMapping commitMapping = dao.getCommit(commit.getLocalId());
        	System.out.println("Commit " + commitMapping.getNode() + " for " + localActivity.getID());
        	if ( firstCommitFound )
        	{
    			commitMapping.setActivity(localActivity);
            	commitMapping.save();
            	pullRequestDao.deleteCommit(commit);
            	if ( !commitMapping.getNode().startsWith(activity.getSource().getCommit().getSha()))
            	{
            		
            	}
        	} else
        	{
        		if ( commitMapping.getNode().startsWith(activity.getSource().getCommit().getSha()))
        		{
        			firstCommitFound = true;
        		}
        	}
            if ( commitMapping.getNode().startsWith(activity.getSource().getCommit().getSha()) != firstCommitFound)
            {
            	commitMapping.setActivity(localActivity);
            	commitMapping.save();
            	firstCommitFound = true;
                break;
            }

//            if (pullRequestContext.getLastUpdateActivityId() != null)
//            {
//            	pullRequestContext.addPullRequesCommitId(
//            			saveCommit(pullRequestContext.getLastUpdateActivityId(), bitbucketPullRequestCommit)
//            			.getID());
//            }
        }
    }
    
    private void fillCommits(BitbucketPullRequestUpdateActivity activity, PullRequestContext pullRequestContext)
    {
    	BitbucketPullRequestCommit firstCommit = pullRequestContext.getFirstCommit();
        
        // check for duplicate activity
        if (firstCommit != null)
        {
	        if (activity != null && firstCommit.getSha().startsWith(activity.getSource().getCommit().getSha()))
	        {
	            return;
	        } else
	        {
	        	pullRequestContext.addPullRequesCommitId(
	        			saveCommit(pullRequestContext.getLastUpdateActivityId(), firstCommit)
	        			.getID());
                pullRequestContext.setFirstCommit(null);
	        }
        }
    	
        Iterable<BitbucketPullRequestCommit> commitsIterator = pullRequestContext.getCommitIterator();
     // when soft sync, it could happen that we have no update activities and therefore no commit iterator
		if (commitsIterator != null)
		{
            for (BitbucketPullRequestCommit bitbucketPullRequestCommit : commitsIterator)
		    {
            	// checking whether commit is already assigned to previously synchronized activity and stop in this case
	        	RepositoryActivityCommitMapping localCommit = dao.getCommitByNode(pullRequestContext.getLocalPullRequestId(), bitbucketPullRequestCommit.getSha());
	            if (localCommit != null)
	            {
	            	break;
	            }
		        if (activity != null && bitbucketPullRequestCommit.getSha().startsWith(activity.getSource().getCommit().getSha()))
		        {
		        	pullRequestContext.setFirstCommit(bitbucketPullRequestCommit);
		            break;
		        }
		
		        if (pullRequestContext.getLastUpdateActivityId() != null)
		        {
		        	pullRequestContext.addPullRequesCommitId(
		        			saveCommit(pullRequestContext.getLastUpdateActivityId(), bitbucketPullRequestCommit)
		        			.getID());
		        }
		    }
        }
    }
    
    private void fillActivityCommits(BitbucketPullRequestActivityInfo activityInfo, PullRequestRemoteRestpoint pullRestpoint, PullRequestContext pullRequestContext)
    {
        if ( !isUpdateActivity(activityInfo.getActivity()))
        {
            return;
        }

        Iterable<BitbucketPullRequestCommit> commitsIterator = pullRequestContext.getCommitIterator();
        if (commitsIterator == null)
        {
            commitsIterator = pullRestpoint.getPullRequestCommits(activityInfo.getPullRequest().getLinks().getCommitsHref());
            pullRequestContext.setCommitIterator(commitsIterator);
        }
        
        fillCommits((BitbucketPullRequestUpdateActivity)activityInfo.getActivity(), pullRequestContext);

    }
    
    private RepositoryActivityCommitMapping saveCommit(Integer activityId, BitbucketPullRequestCommit commit)
    {
        return dao.saveCommit(toDaoModelCommit(commit,activityId));
    }
}
